#!/usr/bin/env python3
"""
Compare training curves from multiple runs (e.g., ResNet vs TinyViT).
Reads metrics.csv files generated by train_resnet_cifar.py / train_tinyvit_cifar.py
and overlays accuracy/loss curves for quick visual comparison.
"""
from __future__ import annotations

import argparse
from pathlib import Path
from typing import List, Sequence

import matplotlib
import matplotlib.pyplot as plt
import pandas as pd


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Overlay metrics from multiple runs (CSV files)."
    )
    parser.add_argument(
        "metric_files",
        nargs="+",
        help="List of metrics.csv paths (runs/.../metrics.csv)",
    )
    parser.add_argument(
        "--labels",
        nargs="*",
        help="Custom labels for each metrics file (defaults to parent folder).",
    )
    parser.add_argument(
        "--output",
        default="runs/comparison.png",
        help="Output image file for the comparison plot.",
    )
    parser.add_argument(
        "--dpi",
        type=int,
        default=200,
        help="Figure DPI when saving.",
    )
    parser.add_argument(
        "--safe",
        action="store_true",
        help="Force non-interactive backend (useful in headless WSL).",
    )
    parser.add_argument(
        "--plots",
        default="acc,loss",
        help="Comma-separated metrics to plot: acc, loss, or acc+loss.",
    )
    return parser.parse_args()


def ensure_backend(use_safe: bool) -> None:
    if use_safe:
        matplotlib.use("Agg")


def load_csv(path: Path) -> pd.DataFrame:
    if not path.exists():
        raise FileNotFoundError(f"metrics file not found: {path}")
    df = pd.read_csv(path)
    if "epoch" in df.columns:
        df = (
            df.sort_values("epoch")
            .drop_duplicates(subset=["epoch"], keep="last")
            .reset_index(drop=True)
        )
    return df


def resolve_label(path: Path, override: str | None) -> str:
    if override:
        return override
    return path.parent.name or path.stem


def find_metrics_path(arg: str) -> Path:
    """Allow passing either metrics.csv files, run directories, or run names."""
    raw_path = Path(arg).expanduser()
    candidates = []
    if raw_path.is_dir():
        candidates.append(raw_path / "metrics.csv")
    candidates.append(raw_path)
    # allow shorthand like "resnet_ft" -> runs/resnet_ft/metrics.csv
    runs_dir = Path("runs") / arg
    if runs_dir.is_dir():
        candidates.append(runs_dir / "metrics.csv")
    elif runs_dir.with_suffix(".csv").exists():
        candidates.append(runs_dir.with_suffix(".csv"))
    else:
        candidates.append(runs_dir)

    for candidate in candidates:
        if candidate.exists():
            path = candidate
            if path.is_dir():
                potential = path / "metrics.csv"
                if potential.exists():
                    return potential.resolve()
            elif path.suffix != ".csv" and (path / "metrics.csv").exists():
                return (path / "metrics.csv").resolve()
            elif path.suffix == ".csv":
                return path.resolve()
    raise FileNotFoundError(
        f"Could not locate metrics.csv from argument '{arg}'. "
        "Pass an explicit CSV path or a run directory containing metrics.csv."
    )


def plot_metrics(
    dfs: List[pd.DataFrame],
    labels: List[str],
    output: Path,
    dpi: int,
    show_acc: bool,
    show_loss: bool,
    safe: bool,
) -> None:
    nrows = (1 if show_acc else 0) + (1 if show_loss else 0)
    fig, axes = plt.subplots(nrows=nrows, ncols=1, figsize=(8, 4 * nrows), sharex=True)
    if nrows == 1:
        axes = [axes]
    idx = 0
    markers = ("o", "s", "^", "D", "v", "P", "*", "X", "h")
    color_cycle: Sequence[str] = plt.rcParams["axes.prop_cycle"].by_key().get("color", [])

    if show_acc:
        ax = axes[idx]
        idx += 1
        for plot_idx, (df, label) in enumerate(zip(dfs, labels)):
            if {"train_acc", "val_acc"}.issubset(df.columns):
                marker = markers[plot_idx % len(markers)]
                color = color_cycle[plot_idx % len(color_cycle)] if color_cycle else None
                ax.plot(
                    df["epoch"],
                    df["train_acc"],
                    marker=marker,
                    linestyle="-",
                    alpha=0.6,
                    color=color,
                    label=f"{label} Train",
                )
                ax.plot(
                    df["epoch"],
                    df["val_acc"],
                    marker=marker,
                    linestyle="--",
                    color=color,
                    label=f"{label} Val",
                )
        ax.set_ylabel("Accuracy (%)")
        ax.set_title("Train / Val Accuracy")
        ax.grid(alpha=0.3, linestyle="--")
        ax.legend()

    if show_loss:
        ax = axes[idx]
        for plot_idx, (df, label) in enumerate(zip(dfs, labels)):
            if {"train_loss", "val_loss"}.issubset(df.columns):
                marker = markers[plot_idx % len(markers)]
                color = color_cycle[plot_idx % len(color_cycle)] if color_cycle else None
                ax.plot(
                    df["epoch"],
                    df["train_loss"],
                    marker=marker,
                    linestyle="-",
                    alpha=0.6,
                    color=color,
                    label=f"{label} Train",
                )
                ax.plot(
                    df["epoch"],
                    df["val_loss"],
                    marker=marker,
                    linestyle="--",
                    color=color,
                    label=f"{label} Val",
                )
        ax.set_ylabel("Loss")
        ax.set_xlabel("Epoch")
        ax.set_title("Train / Val Loss")
        ax.grid(alpha=0.3, linestyle="--")
        ax.legend()

    fig.tight_layout()
    output.parent.mkdir(parents=True, exist_ok=True)
    fig.savefig(output, dpi=dpi, bbox_inches="tight")
    print(f"Saved comparison plot to {output}")

    if not safe:
        try:
            plt.show()
        except Exception as exc:  # pragma: no cover
            print(f"Could not open GUI window ({exc}). Figure saved to {output}.")


def main() -> None:
    args = parse_args()
    ensure_backend(args.safe)

    metric_paths = [find_metrics_path(p) for p in args.metric_files]
    if args.labels and len(args.labels) != len(metric_paths):
        raise ValueError("Number of labels must match number of metric files.")
    labels = [
        resolve_label(path, args.labels[i] if args.labels else None)
        for i, path in enumerate(metric_paths)
    ]
    dfs = [load_csv(path) for path in metric_paths]

    metrics = {m.strip().lower() for m in args.plots.split(",")}
    show_acc = "acc" in metrics
    show_loss = "loss" in metrics
    if not show_acc and not show_loss:
        show_acc = show_loss = True

    output = Path(args.output).expanduser().resolve()
    plot_metrics(dfs, labels, output, args.dpi, show_acc, show_loss, args.safe)


if __name__ == "__main__":
    main()
